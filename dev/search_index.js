var documenterSearchIndex = {"docs":
[{"location":"eventlists/#EventLists","page":"EventLists","title":"EventLists","text":"Depth=1","category":"section"},{"location":"eventlists/#Index","page":"EventLists","title":"Index","text":"","category":"section"},{"location":"eventlists/#MiniEvents.EventLists.add_agent!-Union{Tuple{V}, Tuple{T}, Tuple{T, EventList{T, V}, V}} where {T, V}","page":"EventLists","title":"MiniEvents.EventLists.add_agent!","text":"add_agent!(agent, alist::EventList{T, V}, rates)\n\n\nAdd a new agent to the eventlist.\n\n\n\n\n\n","category":"method"},{"location":"eventlists/#MiniEvents.EventLists.change_rates!-Union{Tuple{V}, Tuple{T}, Tuple{T, EventList{T, V}, V}} where {T, V}","page":"EventLists","title":"MiniEvents.EventLists.change_rates!","text":"change_rates!(agent, alist::EventList{T, V}, rates)\n\n\nChange rates associated with agent object agent.\n\n\n\n\n\n","category":"method"},{"location":"eventlists/#MiniEvents.EventLists.remove_agent!-Tuple{Any, Any}","page":"EventLists","title":"MiniEvents.EventLists.remove_agent!","text":"remove_agent!(agent, alist)\n\n\nRemove an agent from the event list.\n\n\n\n\n\n","category":"method"},{"location":"eventlists/#MiniEvents.EventLists.sum_rates-Union{Tuple{AgentEvents{AT, V}}, Tuple{V}, Tuple{AT}} where {AT, V}","page":"EventLists","title":"MiniEvents.EventLists.sum_rates","text":"sum_rates(a::AgentEvents{AT, V}) -> Any\n\n\nCalculate the sum of all rates assigned to a single agent type.\n\n\n\n\n\n","category":"method"},{"location":"eventlists/#MiniEvents.EventLists.sum_rates-Union{Tuple{EventList{AT, V}}, Tuple{V}, Tuple{AT}} where {AT, V}","page":"EventLists","title":"MiniEvents.EventLists.sum_rates","text":"sum_rates(al::EventList{AT, V}) -> Float64\n\n\nCalculate the sum of all rates assigned to an entire population of agents.\n\n\n\n\n\n","category":"method"},{"location":"eventlists/#MiniEvents.EventLists.AgentEvents","page":"EventLists","title":"MiniEvents.EventLists.AgentEvents","text":"Single agent and the rates of all actions it can do.\n\n\n\n\n\n","category":"type"},{"location":"eventlists/#MiniEvents.EventLists.EventList","page":"EventLists","title":"MiniEvents.EventLists.EventList","text":"All actions currently available to all agents of type AT.\n\n\n\n\n\n","category":"type"},{"location":"eventlists/#MiniEvents.EventLists.EventList-Union{Tuple{}, Tuple{V}, Tuple{AT}} where {AT, V}","page":"EventLists","title":"MiniEvents.EventLists.EventList","text":"Generate an empty EventList.\n\n\n\n\n\n","category":"method"},{"location":"README/#MiniEvents.jl","page":"Introduction","title":"MiniEvents.jl","text":"Minimalistic event based simulation package.\n\nMiniEvents provides a simple macro interface to describe continuous time, discrete events simulations. It uses an efficient simulation algorithm (KÃ¶ster et al., 2024), so that even agent-based models with tens of thousands of agents can easily be handled. It also supports the simultaneous use of different agent types as well as deterministic events and doesn't require any special considerations in the simulation code itself.","category":"section"},{"location":"README/#Simple-example","page":"Introduction","title":"Simple example","text":"As an example let's implement a simple SI model.\n\nWe will start by defining the model without thinking about events or scheduling:\n\n@enum Status susceptible infected\n\nmutable struct Person\n    status :: Status\n    contacts :: Vector{Person}\nend\n\nPerson() = Person(susceptible, [])\n\ninfect!(person) = (person.status = infected)\nheal!(person) = (person.status = susceptible)\n\nAt this point we have the basic workings of a model. Note that this is basically the same implementation we would use if we wanted to use step-wise updates.\n\nTo set up our event-based simulation we have to define events:\n\n\n@events person::Person begin\n    # this is optional, it checks if activated objects have changed state since the last activation\n    @debug\n\n    @rate(count(p->p.status == infected, person.contacts) * 1e-6) ~\n        # this is a boolean condition that determines whether the event can take place\n        person.status == susceptible =>\n        begin\n            infect!(person)\n            # all objects whose event rates are affected need to be refreshed\n            @r person, person.contacts\n        end\n\n    @rate(1e-2) ~\n        person.status == infected =>\n        begin\n            heal!(person)\n            @r person person.contacts\n        end\nend\n\nNow we need to create the main simulation object that will contain the necessary state of the simulator.\n\n# the simulation object has to be told about every type that has events associated with it\n@simulation Sim Person\n\nThis will provide all the machinery of the simulation, but to make this a usable simulation model we will have to add a bit more infrastructure:\n\nmutable struct Model\n    pop :: Vector{Person}\n    sim :: Sim\nend\n\nfunction step!(model)\n    # find and execute the next event in line\n    next_event!(model.sim)\nend\n\nfunction spawn!(model)\n    # before an object can receive events it needs to be activated\n    # spawn_pop! activates a list of objects at once\n    spawn_pop!(model.pop, model.sim)\nend\n\nEverything else that would be needed for a working simulation (e.g. setup, output) can be implemented in exactly the same way as it would for step-wise updating.","category":"section"},{"location":"README/#More-advanced-example","page":"Introduction","title":"More advanced example","text":"We can improve this example with a few convenience features. @simulation supports adding custom properties to the generated simulation type. This way we don't have to keep track of separate simulation and model objects and we can also easily add parameters. So, given these definitions:\n\nstruct World\n    pop :: Vector{Person}\nend\n\n\n@kwdef struct Params\n\tr_inf :: Float64 = 1e-6\n\tr_rec :: Float64 = 1e-2\n\tt_inf :: Float64 = 1.0\nend\n\nwe can now define our simulation like this:\n\n@simulation Model Person World begin\n\tworld :: World\n\tpars :: Params\nend\n\nThen we can replace our hard-coded rates in the event definition:\n\n@events person::Person begin\n    # this is optional, it checks if activated objects have changed state since the last activation\n    @debug\n\n    @rate(count(p->p.status == infected, person.contacts) * @sim().pars.r_inf) ~\n        # this is a boolean condition that determines whether the event can take place\n        person.status == susceptible =>\n        begin\n            infect!(person)\n            # all objects whose event rates are affected need to be refreshed\n            @r person, person.contacts\n        end\n\n    @rate(@sim().pars.r_rec) ~\n        person.status == infected =>\n        begin\n            heal!(person)\n            @r person person.contacts\n        end\nend\n\nNote that the pseudo macro @sim gives us access to the simulation object.\n\nWhile we are at it we can now also define events for World:\n\n@events world::World begin\n\t@debug\n\n\t@repeat(@sim().pars.t_inf) =>\n\tbegin\n\t\tp = rand(world.pop)\n\t\tp.status = infected\n\t\t@r p\n\tend\nend\n\nJust for the sake of demonstration we are using a different event type in this case - @repeat triggers events at exact time points instead of stochastically. This means we also don't have to refresh the world's rate with @r (we do have to refresh the agent we are changing, though).\n\nWith all this in place we can define our step and spawn methods. Since Model is now our simulation type there is no need any more to refer to model.sim separately.\n\nfunction step!(model)\n    # find and execute the next event in line\n    next_event!(model)\nend\n\nfunction MiniEvents.spawn!(model::Model)\n    # before an object can receive events it needs to be activated\n    # spawn_pop! activates a list of objects at once\n    spawn_pop!(model.world.pop, model)\n    spawn!(model.world, model)\nend","category":"section"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"minievents/#MiniEvents","page":"MiniEvents","title":"MiniEvents","text":"Depth=1","category":"section"},{"location":"minievents/#Index","page":"MiniEvents","title":"Index","text":"","category":"section"},{"location":"minievents/#MiniEvents.kill!-Tuple{Any, Any}","page":"MiniEvents","title":"MiniEvents.kill!","text":"kill!(agents, sim)\n\n\nRemove all agent events (rates as well as scheduled). Generic version for iterables of agents.\n\n\n\n\n\n","category":"method"},{"location":"minievents/#MiniEvents.next_event!","page":"MiniEvents","title":"MiniEvents.next_event!","text":"next_event(sim)\n\nFind and execute the next event in sim.\n\n\n\n\n\n","category":"function"},{"location":"minievents/#MiniEvents.now-Tuple{Any}","page":"MiniEvents","title":"MiniEvents.now","text":"now(sim)\n\n\nCurrent time in simulation sim.\n\n\n\n\n\n","category":"method"},{"location":"minievents/#MiniEvents.refresh!-Tuple{Any, Any}","page":"MiniEvents","title":"MiniEvents.refresh!","text":"refresh!(agents, sim)\n\n\nRecalculate event rates for agents. Generic version for iterables of agents.\n\n\n\n\n\n","category":"method"},{"location":"minievents/#MiniEvents.schedule!-NTuple{4, Any}","page":"MiniEvents","title":"MiniEvents.schedule!","text":"schedule!(fun, obj, at, sim)\n\n\nSchedule fun(obj) to be triggered at time at.\n\n\n\n\n\n","category":"method"},{"location":"minievents/#MiniEvents.schedule_dt!-NTuple{4, Any}","page":"MiniEvents","title":"MiniEvents.schedule_dt!","text":"schedule_dt!(fun, obj, dt, sim)\n\n\nSchedule fun(obj) to be triggered at now(sim) + dt.\n\n\n\n\n\n","category":"method"},{"location":"minievents/#MiniEvents.spawn!-Tuple{Any, Any}","page":"MiniEvents","title":"MiniEvents.spawn!","text":"spawn!(a, s)\n\n\nActivate agent by adding its events to the scheduler.\n\n\n\n\n\n","category":"method"},{"location":"minievents/#MiniEvents.spawn_pop!-Tuple{Any, Any}","page":"MiniEvents","title":"MiniEvents.spawn_pop!","text":"spawn_pop!(agents, s)\n\n\nSpawn an entire population of agents.\n\n\n\n\n\n","category":"method"},{"location":"minievents/#MiniEvents.step_dt!-Tuple{Any, Any}","page":"MiniEvents","title":"MiniEvents.step_dt!","text":"step_dt!(sim, dt)\n\n\nProcess events until time has increased by dt.\n\n\n\n\n\n","category":"method"},{"location":"minievents/#MiniEvents.step_until!-Tuple{Any, Any}","page":"MiniEvents","title":"MiniEvents.step_until!","text":"step_until!(sim, t)\n\n\nProcess events until now(sim) >= t.\n\n\n\n\n\n","category":"method"},{"location":"minievents/#MiniEvents.@events-Tuple{Any, Any}","page":"MiniEvents","title":"MiniEvents.@events","text":"@events(decl_agent, block)\n\nParse block to generate event code using agent declaration decl_agent (where decl_agent has the format <name> :: <type>).\n\nblock has to consist of a list of event declaration and directives (in no particular order). \n\nDirectives\n\n@debug\n\nEmits code that compares the current value of an object's rates with the stored values. This is especially useful to catch cases where a required refresh (see below) was emitted.\n\nEvent declarations\n\nMiniEvents provides basic support for deterministic scheduling with @repeat and @at. Note that only one of these event types can occur per event declaration. In addition any number of stochastic events can be declared using @rate or @ratesfor.\n\n@repeat\n\n@repeat(interval) => action\n\nRepeat action every interval time units. @repeat(interval, start) => action Repeat action every interval time units, starting at start.\n\n@at\n\n@at(start) => action\n\nRun action exactly once at start. Note that future actions have to be scheduled manually. \n\n@rate\n\n@rate(rate) ~ condition => action\n\nIf condition is met perform action at rate rate. Note that rates and conditions are evaluated at the point of scheduling and need to be refreshed manually if the agent object's state changes (see below).\n\n@ratesfor\n\n@ratesfor(function, iterator) ~ condition => action\n\nThis allows for the efficient scheduling of an event whose rate is the sum of a number of individual rates when it is important to know which particular individual rate was triggered. For example infection rate of an individual could depend on the number of its contacts, but in some cases we want to know which contact was the source of infection.\n\nScheduling\n\nThe following pseudo macros are used to control scheduling. They generally take one or several arguments (each of which can be an iterable). They can only be used in action blocks.\n\n@r\n\nRefresh an object. This updates the rate and condition. Objects without a rate event can't be refreshed.\n\n@kill\n\nRemove an object from scheduling.\n\n@spawn\n\nAdd a new object to scheduling.\n\nInformation\n\nThese macros provide access to some internal state of the scheduler and take no arguments. They can only be used in action blocks.\n\n@sim\n\nAccess the sim object.\n\n@selected\n\nThe selected item in @ratesfor. \n\n\n\n\n\n","category":"macro"},{"location":"minievents/#MiniEvents.@simulation-Tuple{Any, Vararg{Any}}","page":"MiniEvents","title":"MiniEvents.@simulation","text":"@simulation(name, args...)\n\nGenerate a simulation type named name. args is a list of agent types that can be subject to events (as declared with @events). As an optional last parameter a declaration block can be provided. This block will be included verbatim in the declaration of struct <name> and be used to store global information that needs to be accessible from inside of event code (via the @sim pseudo macro), such as for example parameters or global system state.\n\n\n\n\n\n","category":"macro"},{"location":"scheduler/#Scheduler","page":"Scheduler","title":"Scheduler","text":"Depth=1","category":"section"},{"location":"scheduler/#Index","page":"Scheduler","title":"Index","text":"","category":"section"},{"location":"scheduler/#Base.isempty-Tuple{PQScheduler}","page":"Scheduler","title":"Base.isempty","text":"isempty(scheduler)\n\n\nReturns true if the scheduler does not contain any actions.\n\n\n\n\n\n","category":"method"},{"location":"scheduler/#MiniEvents.Scheduler.advance!-Tuple{Any, Any}","page":"Scheduler","title":"MiniEvents.Scheduler.advance!","text":"advance!(scheduler, t)\n\n\nAdvance time to t. Caution, this does not check for consistency!\n\n\n\n\n\n","category":"method"},{"location":"scheduler/#MiniEvents.Scheduler.next!-Tuple{Any}","page":"Scheduler","title":"MiniEvents.Scheduler.next!","text":"next!(scheduler)\n\n\nRun the next action in scheduler or do nothing if empty. Returns the action's return value.\n\n\n\n\n\n","category":"method"},{"location":"scheduler/#MiniEvents.Scheduler.reset!-Tuple{Any}","page":"Scheduler","title":"MiniEvents.Scheduler.reset!","text":"reset!(scheduler)\n\n\nRemove all actions from scheduler and reset time to 0.\n\n\n\n\n\n","category":"method"},{"location":"scheduler/#MiniEvents.Scheduler.schedule_at!-NTuple{4, Any}","page":"Scheduler","title":"MiniEvents.Scheduler.schedule_at!","text":"schedule_at!(fun, obj, at, scheduler)\n\n\nAdd a single item to the scheduler. Adds function fun to be called on obj at time at to scheduler.\n\n\n\n\n\n","category":"method"},{"location":"scheduler/#MiniEvents.Scheduler.schedule_in!-NTuple{4, Any}","page":"Scheduler","title":"MiniEvents.Scheduler.schedule_in!","text":"schedule_in!(fun, obj, wait, scheduler)\n\n\nAdd a single item (fun to be called on obj) at wait time from now to scheduler.\n\n\n\n\n\n","category":"method"},{"location":"scheduler/#MiniEvents.Scheduler.time_next-Tuple{Any}","page":"Scheduler","title":"MiniEvents.Scheduler.time_next","text":"time_next(scheduler)\n\n\nTime stamp of the next action to be executed by scheduler or time_now if it is empty.\n\n\n\n\n\n","category":"method"},{"location":"scheduler/#MiniEvents.Scheduler.time_now-Tuple{Any}","page":"Scheduler","title":"MiniEvents.Scheduler.time_now","text":"time_now(scheduler)\n\n\nTime stamp of the last action that was executed by scheduler.\n\n\n\n\n\n","category":"method"},{"location":"scheduler/#MiniEvents.Scheduler.unschedule!-Tuple{Any, Any}","page":"Scheduler","title":"MiniEvents.Scheduler.unschedule!","text":"unschedule!(scheduler, obj)\n\n\nRemove action for obj from scheduler.\n\n\n\n\n\n","category":"method"},{"location":"scheduler/#MiniEvents.Scheduler.upto!-Tuple{Any, Any}","page":"Scheduler","title":"MiniEvents.Scheduler.upto!","text":"upto!(scheduler, atime)\n\n\nRun actions in scheduler up to time atime. Returns the scheduler.\n\n\n\n\n\n","category":"method"},{"location":"scheduler/#MiniEvents.Scheduler.PQScheduler","page":"Scheduler","title":"MiniEvents.Scheduler.PQScheduler","text":"A simple scheduler based on PriorityQueue.\n\n\n\n\n\n","category":"type"},{"location":"scheduler/#MiniEvents.Scheduler.PQScheduler-Union{Tuple{}, Tuple{OBJ}, Tuple{TIME}} where {TIME, OBJ}","page":"Scheduler","title":"MiniEvents.Scheduler.PQScheduler","text":"Construct an empty PQScheduler with a give TIME type.\n\n\n\n\n\n","category":"method"}]
}

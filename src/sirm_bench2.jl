using Random
using BenchmarkTools

include("Events.jl")

mutable struct Processes
	conditions :: Vector{Function}
	actions :: Vector{Function}
	rates :: Vector{Function}
end

function addp!(a, p, c, r)
	push!(p.conditions, c)
	push!(p.actions, a)
	push!(p.rates, r)
end

function ratesp(p, agent)
	rates = zeros(Float64, length(p.rates))

	for i in eachindex(p.conditions)
		if p.conditions[i](agent)
			rates[i] = p.rates[i](agent)
		end
	end

	rates
end

function step(alist, processes, r)
	i, r = lookup(alist.sums, r)

	ag = alist.actions[i]
	rs = ag.probs
	person = ag.agent
	funcs = processes.actions

	ret = typeof(person)[]

	for i in eachindex(rs)
		if r < rs[i]
			ret = funcs[i](person, r)
			break
		end
		r -= rs[i]
	end

	for p in ret
		schedule!(p, alist, processes)
	end
end

function schedule!(person, alist, processes)
	change_rates!(person, alist, ratesp(processes, person))
end


# all possible states a person can be in
@enum Status susceptible infected recovered

# this is our agent type
mutable struct Person
    # state
    status :: Status
    # other agents this one can infect or be infected by
    contacts :: Vector{Person}
end

mutable struct World
	x :: Float64
end

# how we construct a person object
Person() = Person(susceptible, [])
Person(state) = Person(state, [])

mutable struct Simulation
    # and this is our population of agents
    pop :: Vector{Person}
	alist :: ActionList{Person}
	processes :: Processes
	alist2 :: ActionList{World}
	processes2 :: Processes
end



function step(sim)
	s = sim.alist.sums[1] + sim.alist2.sums[1]

	r = rand() * s

	if r < sim.alist2.sums[1]
		return step(sim.alist2, sim.processes2, r)
	end

	step(sim.alist, sim.processes, r - sim.alist2.sums[1])
end
		
function create_processes_p()
	pr = Processes([], [], [])

	addp!(pr, 
		p->p.status == infected,
		p->1e-3) do person::Person, r
			person.status = recovered
			[person; person.contacts]
		end
	
	addp!(pr,
		p->p.status == susceptible,
		p->count(ps -> ps.status == infected, p.contacts)) do person::Person, r
			person.status = infected
			[person; person.contacts]
		end
	
	addp!(pr,
		p->p.status == infected,
		p->1e-2) do person::Person, r
			person.status = recovered
			[person; person.contacts]
		end
	
	addp!(pr,
		p->p.status == recovered,
		p->1e-4) do person::Person, r
			person.status = susceptible
			[person]
		end
	
	addp!(pr,
		p->p.status == susceptible,
		p->1e-6) do person::Person, r
			person.status = infected
			[person; person.contacts]
		end
	
	pr
end


function create_processes_w()
	pr = Processes([], [], [])

	addp!(pr,
		p->true,
		p->0.00001) do world, r
			world.x = r
			[world]
		end

	pr
end



function setup_grid(constr, xs, ys)
	# construct the population (contactless for now)
	pop = [ constr(susceptible) for i in 1:xs*ys ]

	# make a matrix to simplify finding neighbours
	matrix = reshape(pop, ys, :)

	for x in 1:xs, y in 1:ys
		p = matrix[y, x]
		if x > 1
			push!(p.contacts, matrix[y, x-1])
		end
		if y > 1
			push!(p.contacts, matrix[y-1, x])
		end
		if x < xs
			push!(p.contacts, matrix[y, x+1])
		end
		if y < ys
			push!(p.contacts, matrix[y+1, x])
		end
	end

	pop
end

function spawn(sim)
    # spawn activates agents
    # this function was generated by the model declaration
    for person in sim.pop
		add_agent!(person, sim.alist, ratesp(sim.processes, person))
    end

	w = World(0.0)
	add_agent!(w, sim.alist2, ratesp(sim.processes2, w))
end

function create_sim(xs, ys)
    pop = setup_grid(Person, xs, ys)

	proc_p = create_processes_p()
	proc_w = create_processes_w()

    # create a simulation object with parameter values
	sim = Simulation(pop, 
		ActionList{Person}(Dict(), [], []), proc_p, 
		ActionList{World}(Dict(), [], []), proc_w)
    
	sim.pop[1, 1].status = infected

	sim
end

function setup_sim(;xs, ys, seed, warmup=3000000)
	sim = create_sim(xs, ys)

	spawn(sim)

    # for reproducibility
    Random.seed!(seed)

	for i in 1:warmup
		step(sim)
	end

    sim
end


function run_sim(sim, n_steps)

	for i in 1:n_steps
		step(sim)
    end
end


function run_bench()
	i = 1
	for grid_size in [2, 4, 8, 16, 32, 64, 128, 256, 512]
		println("grid size: ", grid_size)
		@btime run_sim(sim, 500000) setup=(sim = setup_sim(xs=$grid_size, ys=$grid_size, seed=$i))
		i += 1
	end
end


run_bench()


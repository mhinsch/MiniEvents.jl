using Random
using BenchmarkTools
using StaticArrays

include("MiniEvents.jl")

# all possible states a person can be in
@enum Status susceptible infected recovered

# this is our agent type
mutable struct Person
    # state
    status :: Status
    # other agents this one can infect or be infected by
    contacts :: Vector{Person}
end

mutable struct World
	x :: Float64
end

# how we construct a person object
Person() = Person(susceptible, [])
Person(state) = Person(state, [])

mutable struct Simulation{ALT}
    # and this is our population of agents
    pop :: Vector{Person}
	alists :: ALT
end


# generic parts or need to be generated by macros

# generated
const PVT1 = SVector{3, Float64}
const PVT2 = SVector{1, Float64}

function step(sim)
	dispatch_step(sim.alists...)
end

	
# generated
function step(alist::EventList{World, PVT2}, r)
	w = alist.events[1].agent
	w.x = r

	refresh!(w, alist)
end

# generated
function step(alist::EventList{Person, PVT1}, r)
	#println("lu: ", r)

	i, r = lookup(alist.sums, r)

	#println("-> ", i, " ", r)

	ag = alist.events[i]
	rs = ag.rates
	person = ag.agent

	if (r -= rs[1]) < 0
		person.status = infected

		refresh!(person, alist)
		refresh!(person.contacts, alist)

		return
	end
	
	if (r -= rs[2]) < 0
		person.status = recovered

		refresh!(person, alist)
		refresh!(person.contacts, alist)
		return
	end

	if (r -= rs[3]) < 0
		person.status = susceptible

		refresh!(person, alist)
		return
	end

	println(r, ": ", rs)
	error("something went wrong!")
end

function calc_rates(person::Person)
	PVT1(
		(person.status == susceptible ?
			count(p -> p.status == infected, person.contacts) + 1e-6 : 0.0),
		(person.status == infected ?
			1e-2 : 0.0 ),
		(person.status == recovered ?
			1e-4 : 0.0))
end

function calc_rates(w::World)
	PVT2(0.00001)
end

function refresh!(person::Person, alist)
	change_rates!(person, alist, calc_rates(person))
end

function refresh!(world::World, alist)
	change_rates!(world, alist, calc_rates(world))
end


function setup_grid(constr, xs, ys)
	# construct the population (contactless for now)
	pop = [ constr(susceptible) for i in 1:xs*ys ]

	# make a matrix to simplify finding neighbours
	matrix = reshape(pop, ys, :)

	for x in 1:xs, y in 1:ys
		p = matrix[y, x]
		if x > 1
			push!(p.contacts, matrix[y, x-1])
		end
		if y > 1
			push!(p.contacts, matrix[y-1, x])
		end
		if x < xs
			push!(p.contacts, matrix[y, x+1])
		end
		if y < ys
			push!(p.contacts, matrix[y+1, x])
		end
	end

	pop
end

function spawn(sim)
    # spawn activates agents
    # this function was generated by the model declaration
    for person in sim.pop
		add_agent!(person, sim.alists[1], calc_rates(person))
    end

	w = World(0.0)
	add_agent!(w, sim.alists[2], calc_rates(w))
end

function create_sim(xs, ys)
    pop = setup_grid(Person, xs, ys)

    # create a simulation object with parameter values
	sim = Simulation(pop, (EventList{Person, PVT1}(), EventList{World, PVT2}()))
    
	sim.pop[1, 1].status = infected

	sim
end

function setup_sim(;xs, ys, seed, warmup=3000000)
	sim = create_sim(xs, ys)

	spawn(sim)

    # for reproducibility
    Random.seed!(seed)

	for i in 1:warmup
		step(sim)
	end

    sim
end


function run_sim(sim, n_steps)

	for i in 1:n_steps
		step(sim)
    end
end

function check_sum(n)
	# check correctness
	c = 0
	for i in 1:n
		sim = setup_sim(xs=100, ys=100, seed=i+41)
		run_sim(sim, 500000)
		c += count(p->p.status==recovered, sim.pop)
		print(".")
	end
	println; println(c/n)
end

function run_bench()
	i = 1
	for grid_size in [2, 4, 8, 16, 32, 64, 128, 256, 512]
		println("grid size: ", grid_size)
		@btime run_sim(sim, 500000) setup=(sim = setup_sim(xs=$grid_size, ys=$grid_size, seed=$i))
		i += 1
	end
end

check_sum(1)
run_bench()


